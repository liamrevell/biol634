x<-fastBM(tree,alpha=1)
x<-fastBM(tree,alpha=1,theta=0)
geiger::fitContinuous(tree,x)
geiger::fitContinuous(tree,x,model="OU")
?rTraitCont
?fastBM
tree<-pbtree(n=500,scale=1)
x<-fastBM(tree,alpha=1,theta=0)
geiger::fitContinuous(tree,x,model="OU")
?rTraitCont
?fastBM
tree<-pbtree(n=1000,scale=1)
x<-fastBM(tree,alpha=0.5,theta=0)
geiger::fitContinuous(tree,x,model="OU")
?rTraitCont
?fastBM
tree<-pbtree(n=2000,scale=1)
x<-fastBM(tree,alpha=0.5,theta=0)
geiger::fitContinuous(tree,x,model="OU")
?rTraitCont
?fastBM
tree<-pbtree(n=2000,scale=1)
x<-fastBM(tree,alpha=0.8,theta=0)
geiger::fitContinuous(tree,x,model="OU")
?rTraitCont
?fastBM
tree<-pbtree(n=5000,scale=1)
x<-fastBM(tree,alpha=0.8,theta=0)
geiger::fitContinuous(tree,x,model="OU")
tree<-pbtree(N=100,b=1,d=0.3)
tree<-pbtree(n=100,b=1,d=0.3)
tree
library(phangorn)
howmanytrees()
howmanytrees(10)
howmanytrees(20)
?howmanytrees
phangorn::howmanytrees(n=15)
## load packages
library(phytools)
library(geiger)
## load some data
data("cordylid.tree")
## plot this tree
plotTree(cordylid.tree,ftype="i")
## plot this tree
plotTree(cordylid.tree,ftype="i",fsize=0.9)
args(nodelabels)
nodelabels(cex=0.6,frame="circle",bg="white")
## load in my data
data("cordylid.data")
head(cordylid.data)
##
cordylid_armoring<-setNames(cordylid.data$pPC1,
rownames(cordylid.data))
cordylid_armoring
## estimate ML ancestral states using fastAnc
cordylid_ml<-fastAnc(cordylid.tree,cordylid_armoring)
cordylid_ml
## estimate ML ancestral states using fastAnc
cordylid_ml<-fastAnc(cordylid.tree,cordylid_armoring,
CI=TRUE)
cordylid_ml
## compare 95% CI on root to range of trait
range(cordylid_armoring)
## visualize our reconstruction using contMap
cordylid_cmap<-contMap(cordylid.tree,cordylid_armoring,
plot=FALSE)
cordylid_cmap
plot(cordylid_cmap)
plot(cordylid_cmap,fsize=0.8)
## update our color gradient
cordylid_cmap<-setMap(cordylid_cmap,hcl.colors(n=100))
plot(cordylid_cmap,fsize=0.8)
nodelabels(cex=0.6,frame="circle",bg="white")
## let's Bayesian MCMC ancestral state reconstruction
cordylid_mcmc<-anc.Bayes(cordylid.tree,
cordylid_armoring,ngen=500000)
anc.Bayes
## informative prior on the root
Prior_mean<-c(1000,min(cordylid_armoring),
rep(mean(cordylid_armoring,cordylid.tree$Nnode)))
Prior_mean
## informative prior on the root
Prior_mean<-c(1000,min(cordylid_armoring),
rep(mean(cordylid_armoring),cordylid.tree$Nnode))
Prior_mean
var(cordylid_armoring)
Prior_var<-c(1e6,0.25,rep(1000,cordylid.tree$Nnode-1))
cordylid_mcmc.informative<-anc.Bayes(cordylid.tree,
cordylid_armoring,ngen=500000,
control=list(pr.mean=Prior_mean,pr.var=Prior_var))
cordylid_mcmc.informative$ace
cordylid_mcmc.informative
Prior_var<-c(1e6,0.01,rep(1000,cordylid.tree$Nnode-1))
cordylid_mcmc.informative<-anc.Bayes(cordylid.tree,
cordylid_armoring,ngen=500000,
control=list(pr.mean=Prior_mean,pr.var=Prior_var))
cordylid_mcmc.informative
cordyld_mcmc
cordylid_mcmc
dev.off()
cordylid_ml
str(cordylid_mcmc)
obj<-print(cordylid_mcmc)
str(obj)
plot(cordylid_ml$ace,obj)
plot(cordylid_ml$ace,obj,bty="n",pch=21,pt.bg="grey",
xlab="ML estimates",ylab="Bayesian estimates")
plot(cordylid_ml$ace,obj,bty="n",pch=21,bg="grey",
xlab="ML estimates",ylab="Bayesian estimates")
plot(cordylid_ml$ace,obj,bty="n",pch=21,bg="grey",
xlab="ML estimates",ylab="Bayesian estimates",
las=1)
grid()
min(cordylid_armoring)
cordylid.tree$Nnode
## let's specify an informative prior
Prior_mean<-c(
1000,
min(cordylid_armoring),
rep(mean(cordylid_armoring),cordylid.tree$Nnode-1))
var(cordylid_armoring)
Prior_var<-c(
1e6,
0.01,
rep(1000,cordylid.tree$Nnode-1))
cordylid_mcmc.informative<-anc.Bayes(cordylid.tree,
cordylid_armoring,ngen=500000,
control=list(pr.mean=Prior_mean,
pr.var=Prior_var))
cordylid_mcmc.informative
obj<-print(cordylid_mcmc.informative)
plot(cordylid_ml$ace,obj,bty="n",pch=21,bg="grey",
xlab="ML estimates",ylab="Bayesian estimates (informative prior)",
las=1)
grid()
cordylid_cmap.bayes<-contMap(cordylid_tree,
cordylid_armoring,anc.states=obj$ace,plot=FALSE)
cordylid_cmap.bayes<-contMap(cordylid.tree,
cordylid_armoring,anc.states=obj$ace,plot=FALSE)
cordylid_cmap.bayes<-contMap(cordylid.tree,
cordylid_armoring,anc.states=obj$ace,plot=FALSE)
cordylid_cmap.bayes<-setMap(cordylid_cmap.bayes,
hcl.colors(n=100))
plot(cordylid_cmap.bayes,fsize=0.8)
cordylid_cmap.bayes<-contMap(cordylid.tree,
cordylid_armoring,anc.states=obj,plot=FALSE)
cordylid_cmap.bayes<-setMap(cordylid_cmap.bayes,
hcl.colors(n=100))
plot(cordylid_cmap.bayes,fsize=0.8)
dev.off()
obj<-print(cordylid_mcmc.informative)
plot(cordylid_ml$ace,obj,bty="n",pch=21,bg="grey",
xlab="ML estimates",ylab="Bayesian estimates (informative prior)",
las=1)
grid()
cordylid_cmap.bayes<-contMap(cordylid.tree,
cordylid_armoring,anc.states=obj,plot=FALSE)
cordylid_cmap.bayes<-setMap(cordylid_cmap.bayes,
hcl.colors(n=100))
plot(cordylid_cmap.bayes,fsize=0.8)
cordylid_cmap.bayes<-contMap(cordylid.tree,
cordylid_armoring,method="user",
anc.states=obj,plot=FALSE)
cordylid_cmap.bayes<-setMap(cordylid_cmap.bayes,
hcl.colors(n=100))
plot(cordylid_cmap.bayes,fsize=0.8)
plot(cordylid_cmap,ftype="off")
par(mfrow=c(1,2))
plot(cordylid_cmap,ftype="off")
plot(cordylid_cmap.bayes,ftype="off",
direction="leftwards")
plot(cordylid_cmap,ftype="off",fsize=0.6)
plot(cordylid_cmap.bayes,ftype="off",
direction="leftwards",fsize=0.6)
dev.off()
plot(cordylid_cmap.bayes,ftype="off",
direction="leftwards",fsize=0.6)
plot(cordylid_cmap.bayes,ftype="off",
direction="rightwards",fsize=0.6)
nodelabels(frame="circle",cex=0.6)
cordylid_node.42<-density(cordylid_mcmc.informative,what=42)
dev.off()
plot(cordylid_node.42)
cordylid_node.42
## load primate data
data(primate.tree)
data(primate.data)
## pull out our character
activity<-setNames(primate.data$Activity_pattern,
rownames(primate.data))
activity
## fit three models: ER, SYM, ARD models
er_primates<-fitMk(primate.tree,activity,
model="ER")
sym_primates<-fitMk(primate.tree,activity,
model="SYM")
ard_primates<-fitMk(primate.tree,activity,
model="ARD")
## traditionally, we would compare these three
## models and choose the "best"
anova(er_primates,
sym_primates,
ard_primates)
## estimate marginal ancestral states under
## "best" (i.e., ER) model
primate_er.marginal<-ancr(er_primates)
primate_er.marginal
## we can plot this
plot(primate_er.marginal)
## we can plot this
plot(primate_er.marginal,
args.plotTree=list(direction="upwards"))
## we can plot this
plot(primate_er.marginal,
args.plotTree=list(direction="upwards"),
args.nodelabels=list(piecol=c("yellow","pink","purple")))
## we can plot this
plot(primate_er.marginal,
args.plotTree=list(direction="upwards"),
args.nodelabels=list(piecol=c("pink","yellow","purple")))
## we can plot this
plot(primate_er.marginal,
args.plotTree=list(direction="upwards"),
args.nodelabels=list(piecol=c("pink","yellow","navy")))
## we can plot this
plot(primate_er.marginal,
args.plotTree=list(direction="upwards"),
args.nodelabels=list(piecol=c("pink","gold","navy")))
## we can plot this
plot(primate_er.marginal,
args.plotTree=list(direction="upwards",type="fan"),
args.nodelabels=list(piecol=c("pink","gold","navy")))
## we can plot this
plot(primate_er.marginal,
args.plotTree=list(direction="upwards"),
args.nodelabels=list(piecol=c("pink","gold","navy")))
## re-calculate our model comparison
anova(er_primates,
sym_primates,
ard_primates)->aov_primates
aov_primates
primate_modelaveraged.marginal<-ancr(aov_primates)
primate_modelaveraged.marginal
plot(primate_modelaveraged.marginal,
args.plotTree=list(direction="upwards"),
args.nodelabels=list(piecol=c("pink","gold","navy")))
library(phytools)
data(sunfish.tree)
tree<-as.phylo(sunfish.tree)
data(sunfish.data)
x<-setNames(sunfish.data$feeding.mode,
rownames(x))
x<-setNames(sunfish.data$feeding.mode,
rownames(sunfish.data))
fit<-fitThresh(tree,x)
str(fit)
fit$mk_fit
args(ancr)
ancr.fitMk
phytools:::ancr.fitMk
object<-ancr(fit$mk_fit,tips=TRUE)
dim(object)
dim(object$ace)
head(object$ace)
plot(object$ace[1,])
plot(object$ace[1,],type="l")
plot(object$ace[2,],type="l")
plot(object$ace[3,],type="l")
plot(object$ace[4,],type="l")
plot(object$ace[5,],type="l")
Ntip(tree)
plot(object$ace[28,],type="l")
plot(object$ace[29,],type="l")
y<-fastBM(tree)
x<-as.factor(sapply(y,function(x) if(x>0) "a" else "b"))
x
fit<-fitThresh(tree,x)
fit$mk_fit
object<-ancr(fit$mk_fit,tips=TRUE)
dim(object$ace)
head(object$ace)
plot(object$ace[29,],type="l")
plot(object$ace[1,],type="l")
plot(object$ace[2,],type="l")
plot(object$ace[3,],type="l")
apply(object$ace,1,which.max)
str(fit)
est.y<-fit$liability[apply(object$ace,1,which.max)]
est.y
plot(y,est.y[1:Ntip(tree)])
abline(-1,0)
args(abline)
abline(0,-1)
plot(y,est.y[1:Ntip(tree)],bty="n",pch=22,bg="grey")
abline(0,-1,lwd=2,col="blue")
library(phytools)
tree<-pbtree(n=100)
y<-fastBM(tree)
x<-as.factor(sapply(y,function(x) if(x<0) "a" else "b"))
fit<-fitThresh(tree,x)
fit$mk_fit
object<-ancr(fit$mk_fit,tips=TRUE)
dim(object$ace)
head(object$ace)
plot(object$ace[3,],type="l")
est.y<-fit$liability[apply(object$ace,1,which.max)]
est.y
plot(y,est.y[1:Ntip(tree)],bty="n",pch=21,bg="grey")
abline(0,-1,lwd=2,col="blue")
plot(y,est.y[1:Ntip(tree)],bty="n",pch=21,bg="grey")
abline(0,1,lwd=2,col="blue")
plot(object$ace[1,],type="l")
str(fit)
delta<-fit$liability[2]-fit$liability[1]
delta
plot(fit$liability,object$ace[1,],type="l")
plot(fit$liability,object$ace[1,],type="s")
plot(fit$liability,object$ace[1,]/delta,type="s")
fit<-fitThresh(tree,x,levs=50)
delta<-fit$liability[2]-fit$liability[1]
object<-ancr(fit$mk_fit,tips=TRUE)
dim(object$ace)
plot(fit$liability,object$ace[1,]/delta,type="s")
plot(fit$liability,object$ace[1,]/delta) #,type="s")
abline(h=0)
abline(v=0)
plot(fit$liability,object$ace[1,]/delta,type="s")
abline(v=0)
fit<-fitThresh(tree,x,levs=100)
delta<-fit$liability[2]-fit$liability[1]
object<-ancr(fit$mk_fit,tips=TRUE)
dim(object$ace)
head(object$ace)
plot(fit$liability,object$ace[1,]/delta,type="s")
est.y<-fit$liability[apply(object$ace,1,which.max)]
est.y
abline(v=0)
fit<-fitThresh(tree,x,levs=200)
delta<-fit$liability[2]-fit$liability[1]
object<-ancr(fit$mk_fit,tips=TRUE)
dim(object$ace)
head(object$ace)
abline(v=0,lty="dotted")
plot(fit$liability,object$ace[1,]/delta,type="s")
abline(v=0,lty="dotted")
plot(fit$liability,object$ace[1,]/delta,type="s",
bty="n",xlab="liability",ylab="density")
grid()
par(mfrow=c(5.1,4.1,2.1,2.1))
plot(fit$liability,object$ace[1,]/delta,type="s",
bty="n",xlab="liability",ylab="density")
grid()
par(mar=c(5.1,4.1,2.1,2.1))
plot(fit$liability,object$ace[1,]/delta,type="s",
bty="n",xlab="liability",ylab="density")
grid()
abline(v=0,lty="dotted")
text(0,0.8*par()$usr[4],"threshold",srt=90)
text(0.1,0.8*par()$usr[4],"threshold",srt=90)
plot(fit$liability,object$ace[1,]/delta,type="s",
bty="n",xlab="liability",ylab="density")
grid()
abline(v=0,lty="dotted")
text(0.1,0.8*par()$usr[4],"threshold",srt=90)
est.y<-fit$liability[apply(object$ace,1,which.max)]
est.y
plot(y,est.y[1:Ntip(tree)],bty="n",pch=21,bg="grey")
abline(0,1,lwd=2,col="blue")
grid()
plot(y,est.y[1:Ntip(tree)],bty="n",pch=21,bg="grey")
abline(0,1,lwd=2,col="blue",xlab="simulated liability",
"estimated liability")
grid()
abline(0,1,lwd=2,col="blue",xlab="simulated liability",
ylab="estimated liability")
plot(y,est.y[1:Ntip(tree)],bty="n",pch=21,bg="grey",
xlab="simulated liability",
ylab="estimated liability")
abline(0,1,lwd=2,col="blue")
grid()
## load phytools
library(phytools)
## simulate tree
tree<-pbtree(n=100)
## simulate liabilities
y<-fastBM(tree)
## simulate threshold trait
x<-as.factor(sapply(y,function(x) if(x<0) "a" else "b"))
## fit threshold model
fit<-fitThresh(tree,x,levs=200)
## compute "delta"
## (this is just to get the density from the prob.)
delta<-fit$liability[2]-fit$liability[1]
## apply ancr to fit$mk_fit object
object<-ancr(fit$mk_fit,tips=TRUE)
## graph the likelihood function for tip #1
## (can change for any node)
par(mar=c(5.1,4.1,2.1,2.1))
plot(fit$liability,object$ace[1,]/delta,type="s",
bty="n",xlab="liability",ylab="density")
grid()
abline(v=0,lty="dotted")
text(0.1,0.8*par()$usr[4],"threshold",srt=90)
## estimate tip liabilities
est.y<-fit$liability[apply(object$ace,1,
which.max)][1:Ntip(tree)]
## graph compared to generating liabilities
plot(y,est.y[1:Ntip(tree)],bty="n",pch=21,bg="grey",
xlab="simulated liability",
ylab="estimated liability")
abline(0,1,lwd=2,col="blue")
grid()
## graph the likelihood function for tip #1
## (can change for any node)
tip<-1
par(mar=c(5.1,4.1,2.1,2.1))
plot(fit$liability,object$ace[tip,]/delta,type="s",
bty="n",xlab="liability",ylab="density")
grid()
abline(v=0,lty="dotted")
text(0.1,0.8*par()$usr[4],"threshold",srt=90)
library(phytools)
tree<-read.tree(
text="((A:0.3,B:0.3):0.4,C:0.7);"
)
plotTree(tree)
X<-fastBM(tree,nsim=1)
X
X<-fastBM(tree,nsim=100)
X
X<-t(X)
X
pairs(X)
X<-fastBM(tree,nsim=1000)
X
X<-t(X)
X
pairs(X)
tree<-read.tree(
text="((A:0.1,B:0.1):0.6,C:0.7);"
)
plotTree(tree)
X<-fastBM(tree,nsim=1)
X
X<-fastBM(tree,nsim=1000)
X
X<-t(X)
X
pairs(X)
X<-fastBM(tree,nsim=1000,internal=TRUE)
X<-t(X)
head(X)
X<-X[,-4]
head(X)
pairs(X)
library(phytools)
data("liolaemid.tree")
data("liolaemid.data")
head(liolaemid.data)
liol_temp<-setNames(liolaemid.data$temperature,
rownames(liolaemid.data))
## we are going to reconstruct using phytools::fastAnc
?fastAnc
liol_temp.asr<-fastAnc(liolaemid.tree,liol_temp,
CI=TRUE)
geiger::name.check(liolaemid.tree,liolaemid.data)
liol_temp[liolaemid.tree$tip.label]
## check for mismatches (there is one mismatch)
geiger::name.check(liolaemid.data,liolaemid.tree)
## check for mismatches (there is one mismatch)
geiger::name.check(liolaemid.data)
args(geiger::name.check)
## check for mismatches (there is one mismatch)
geiger::name.check(data=liolaemid.data,phy=liolaemid.tree)
liol_temp.asr<-fastAnc(liolaemid.tree,liol_temp,
CI=TRUE)
liol_temp<-liol_temp[liolaemid.tree$tip.label]
liol_temp.asr<-fastAnc(liolaemid.tree,liol_temp,
CI=TRUE)
## here is our reconstruction
liol_temp.asr
print(liol_temp.asr,printlen=10)
## compare CI at root to the range of the data
range(liol_temp)
## let's plot our tree
plotTree(liolaemid.tree,ftype="off",lwd=1)
## let's do a contMap
liol_temp.cMap<-contMap(liolaemid.tree,liol_temp)
## recolor this & regraph it
liol_temp.cMap<-setMap(liol_temp.cMap,c("blue","red"))
plot(liol_temp.cMap,lwd=2,outline=FALSE,fsize=0.4)
plot(liol_temp.cMap,lwd=2,outline=FALSE,fsize=c(0.4,1))
plot(liol_temp.cMap,lwd=c(2,10),outline=FALSE,fsize=c(0.4,1))
plot(liol_temp.cMap,lwd=c(3,10),outline=FALSE,fsize=c(0.4,1))
plot(liol_temp.cMap,lwd=c(3,10),outline=FALSE,fsize=c(0.4,1),
ftype="off")
## recolor this & regraph it
liol_temp.cMap<-setMap(liol_temp.cMap,c("lightblue","red"))
plot(liol_temp.cMap,lwd=c(3,10),outline=FALSE,fsize=c(0.4,1),
ftype="off")
## recolor this & regraph it
liol_temp.cMap<-setMap(liol_temp.cMap,c("green","yellow","red"))
plot(liol_temp.cMap,lwd=c(3,10),outline=FALSE,fsize=c(0.4,1),
ftype="off")
## recolor this & regraph it
liol_temp.cMap<-setMap(liol_temp.cMap,c("darkgreen","yellow","red"))
plot(liol_temp.cMap,lwd=c(3,10),outline=FALSE,fsize=c(0.4,1),
ftype="off")
getwd()
setwd("courses/BIOL634-fall2025/biol634/")
