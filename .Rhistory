dimnames=list(0:5,0:5))
squamate_lossgain_2r<-fitMk(squamate_tree,hind_digits,
model=D,pi="fitzjohn")
## fit loss/gain multi-rate model
D<-matrix(c(
0,6,0,0,0,0,
1,0,7,0,0,0,
0,2,0,8,0,0,
0,0,3,0,9,0,
0,0,0,4,0,10,
0,0,0,0,5,0),
6,6,byrow=TRUE,
dimnames=list(0:5,0:5))
squamate_lossgain_10r<-fitMk(squamate_tree,hind_digits,
model=D,pi="fitzjohn")
## fit loss/gain + jump model
D<-matrix(c(
0,7,0,0,0,0,
1,0,8,0,0,0,
6,2,0,9,0,0,
6,0,3,0,10,0,
6,0,0,4,0,11,
6,0,0,0,5,0),
6,6,byrow=TRUE,
dimnames=list(0:5,0:5))
squamate_lossgain_jump<-fitMk(squamate_tree,hind_digits,
model=D,pi="fitzjohn")
## compare among all fitted models (sorted by complexity)
anova(
squamate_er,
squamate_lossonly_1r,
squamate_lossgain_2r,
squamate_lossonly_5r,
squamate_lossonly_jump,
squamate_lossgain_10r,
squamate_lossgain_jump)
## from this we see evidence that we FAILED to converge to the
## true MLEs for our two most complex models. Why do I think that?
## let's run multiple optimization iterations in parallel
## load required packages
library(foreach)
library(doParallel)
niter<-20 ## number of iterations
ncores<-min(niter,detectCores()-4) ## number of cores (leave 4 free)
mc<-makeCluster(ncores,type="PSOCK")
registerDoParallel(cl=mc)
## loss/gain multi-rate model design matrix
D<-matrix(c(
0,6,0,0,0,0,
1,0,7,0,0,0,
0,2,0,8,0,0,
0,0,3,0,9,0,
0,0,0,4,0,10,
0,0,0,0,5,0),
6,6,byrow=TRUE,
dimnames=list(0:5,0:5))
lossgain10r_fits<-foreach(i=1:niter)%dopar%{
phytools::fitMk(squamate_tree,hind_digits,
model=D,pi="fitzjohn",rand_start=TRUE,
lik.func="lik",logscale=sample(c(TRUE,FALSE),1))
}
## get log-likelihoods
lnL<-sapply(lossgain10r_fits,logLik)
lnL
## new best model
squamate_lossgain_10r<-lossgain10r_fits[[which.max(lnL)]]
## loss/gain + jump design matrix
D<-matrix(c(
0,7,0,0,0,0,
1,0,8,0,0,0,
6,2,0,9,0,0,
6,0,3,0,10,0,
6,0,0,4,0,11,
6,0,0,0,5,0),
6,6,byrow=TRUE,
dimnames=list(0:5,0:5))
lossgainjump_fits<-foreach(i=1:niter)%dopar%{
phytools::fitMk(squamate_tree,hind_digits,
model=D,pi="fitzjohn",rand_start=TRUE,
lik.func="lik",logscale=sample(c(TRUE,FALSE),1))
}
## get log-likelihoods
lnL<-sapply(lossgainjump_fits,logLik)
lnL
## new best model
squamate_lossgain_jump<-lossgainjump_fits[[which.max(lnL)]]
## stop cluster
stopCluster(cl=mc)
## re-run comparison
anova(
squamate_er,
squamate_lossonly_1r,
squamate_lossgain_2r,
squamate_lossonly_5r,
squamate_lossonly_jump,
squamate_lossgain_10r,
squamate_lossgain_jump)
lnL
squamate_lossgain_10r
squamate_lossgain_jump
squamate_lossgain_10r
## re-run comparison
anova(
squamate_er,
squamate_lossonly_1r,
squamate_lossgain_2r,
squamate_lossonly_5r,
squamate_lossonly_jump,
squamate_lossgain_10r,
squamate_lossgain_jump)
length(lnL0)
length(lnL)
## homework details: https://liamrevell.github.io/biol634/hw/4/hw4-problem.html
## load packages
library(phytools)
library(geiger)
## in class we loaded & cleaned up the data as follows
## load data
squamate_data<-read.csv(
file="https://liamrevell.github.io/biol634/data/brandley_table.csv",
row.names=1)
## load tree
squamate_tree<-read.nexus(
file="https://liamrevell.github.io/biol634/data/squamate.tre")
## gsub " " for "_" in species labels of data
rownames(squamate_data)<-gsub(" ","_",rownames(squamate_data))
## still a name mismatch
name.check(squamate_tree,squamate_data)
## subsample squamate_data
squamate_data<-squamate_data[squamate_tree$tip.label,]
## pull out hind digits & round
hind_digits<-setNames(squamate_data$Toes,
rownames(squamate_data))
hind_digits<-round(hind_digits)
## fit ER model
squamate_er<-fitMk(squamate_tree,hind_digits,model="ER",
pi="fitzjohn")
## fit 1-rate loss-only model
D<-matrix(c(
0,0,0,0,0,0,
1,0,0,0,0,0,
0,1,0,0,0,0,
0,0,1,0,0,0,
0,0,0,1,0,0,
0,0,0,0,1,0),
6,6,byrow=TRUE,
dimnames=list(0:5,0:5))
squamate_lossonly_1r<-fitMk(squamate_tree,hind_digits,
model=D,pi="fitzjohn")
## fit loss-only multi-rate model
D<-matrix(c(
0,0,0,0,0,0,
1,0,0,0,0,0,
0,2,0,0,0,0,
0,0,3,0,0,0,
0,0,0,4,0,0,
0,0,0,0,5,0),
6,6,byrow=TRUE,
dimnames=list(0:5,0:5))
squamate_lossonly_5r<-fitMk(squamate_tree,hind_digits,
model=D,pi="fitzjohn")
## fit ordered + jump model
D<-matrix(c(
0,0,0,0,0,0,
1,0,0,0,0,0,
6,2,0,0,0,0,
6,0,3,0,0,0,
6,0,0,4,0,0,
6,0,0,0,5,0),
6,6,byrow=TRUE,
dimnames=list(0:5,0:5))
squamate_lossonly_jump<-fitMk(squamate_tree,hind_digits,
model=D,pi="fitzjohn")
## fit loss/gain two-rate model
D<-matrix(c(
0,2,0,0,0,0,
1,0,2,0,0,0,
0,1,0,2,0,0,
0,0,1,0,2,0,
0,0,0,1,0,2,
0,0,0,0,1,0),
6,6,byrow=TRUE,
dimnames=list(0:5,0:5))
squamate_lossgain_2r<-fitMk(squamate_tree,hind_digits,
model=D,pi="fitzjohn")
## fit loss/gain multi-rate model
D<-matrix(c(
0,6,0,0,0,0,
1,0,7,0,0,0,
0,2,0,8,0,0,
0,0,3,0,9,0,
0,0,0,4,0,10,
0,0,0,0,5,0),
6,6,byrow=TRUE,
dimnames=list(0:5,0:5))
squamate_lossgain_10r<-fitMk(squamate_tree,hind_digits,
model=D,pi="fitzjohn")
## fit loss/gain + jump model
D<-matrix(c(
0,7,0,0,0,0,
1,0,8,0,0,0,
6,2,0,9,0,0,
6,0,3,0,10,0,
6,0,0,4,0,11,
6,0,0,0,5,0),
6,6,byrow=TRUE,
dimnames=list(0:5,0:5))
squamate_lossgain_jump<-fitMk(squamate_tree,hind_digits,
model=D,pi="fitzjohn")
## compare among all fitted models (sorted by complexity)
anova(
squamate_er,
squamate_lossonly_1r,
squamate_lossgain_2r,
squamate_lossonly_5r,
squamate_lossonly_jump,
squamate_lossgain_10r,
squamate_lossgain_jump)
## from this we see evidence that we FAILED to converge to the
## true MLEs for our two most complex models. Why do I think that?
## let's run multiple optimization iterations in parallel
## load required packages
library(foreach)
library(doParallel)
niter<-30 ## number of iterations
ncores<-min(niter,detectCores()-4) ## number of cores (leave 4 free)
mc<-makeCluster(ncores,type="PSOCK")
registerDoParallel(cl=mc)
## loss/gain multi-rate model design matrix
D<-matrix(c(
0,6,0,0,0,0,
1,0,7,0,0,0,
0,2,0,8,0,0,
0,0,3,0,9,0,
0,0,0,4,0,10,
0,0,0,0,5,0),
6,6,byrow=TRUE,
dimnames=list(0:5,0:5))
lossgain10r_fits<-foreach(i=1:niter)%dopar%{
phytools::fitMk(squamate_tree,hind_digits,
model=D,pi="fitzjohn",rand_start=TRUE,
lik.func="lik",logscale=sample(c(TRUE,FALSE),1))
}
## get log-likelihoods
lnL<-sapply(lossgain10r_fits,logLik)
lnL
## new best model
squamate_lossgain_10r<-lossgain10r_fits[[which.max(lnL)]]
## loss/gain + jump design matrix
D<-matrix(c(
0,7,0,0,0,0,
1,0,8,0,0,0,
6,2,0,9,0,0,
6,0,3,0,10,0,
6,0,0,4,0,11,
6,0,0,0,5,0),
6,6,byrow=TRUE,
dimnames=list(0:5,0:5))
lossgainjump_fits<-foreach(i=1:niter)%dopar%{
phytools::fitMk(squamate_tree,hind_digits,
model=D,pi="fitzjohn",rand_start=TRUE,
lik.func="lik",logscale=sample(c(TRUE,FALSE),1))
}
## get log-likelihoods
lnL<-sapply(lossgainjump_fits,logLik)
lnL
## new best model
squamate_lossgain_jump<-lossgainjump_fits[[which.max(lnL)]]
## stop cluster
stopCluster(cl=mc)
## re-run comparison
anova(
squamate_er,
squamate_lossonly_1r,
squamate_lossgain_2r,
squamate_lossonly_5r,
squamate_lossonly_jump,
squamate_lossgain_10r,
squamate_lossgain_jump)
squamate_lossgain_jump
squamate_lossgain_10r
niter<-30 ## number of iterations
ncores<-min(niter,detectCores()-4) ## number of cores (leave 4 free)
mc<-makeCluster(ncores,type="PSOCK")
registerDoParallel(cl=mc)
lossgainjump_fits<-foreach(i=1:niter)%dopar%{
phytools::fitMk(squamate_tree,hind_digits,
model=D,pi="fitzjohn",rand_start=TRUE,
lik.func="lik",logscale=FALSE) #sample(c(TRUE,FALSE),1))
}
## get log-likelihoods
lnL<-sapply(lossgainjump_fits,logLik)
lnL
## new best model
squamate_lossgain_jump<-lossgainjump_fits[[which.max(lnL)]]
## stop cluster
stopCluster(cl=mc)
## re-run comparison
anova(
squamate_er,
squamate_lossonly_1r,
squamate_lossgain_2r,
squamate_lossonly_5r,
squamate_lossonly_jump,
squamate_lossgain_10r,
squamate_lossgain_jump)
squamate_lossgain_jump
lnL
niter<-30 ## number of iterations
ncores<-min(niter,detectCores()-4) ## number of cores (leave 4 free)
mc<-makeCluster(ncores,type="PSOCK")
registerDoParallel(cl=mc)
## loss/gain + jump design matrix
D<-matrix(c(
0,7,0,0,0,0,
1,0,8,0,0,0,
6,2,0,9,0,0,
6,0,3,0,10,0,
6,0,0,4,0,11,
6,0,0,0,5,0),
6,6,byrow=TRUE,
dimnames=list(0:5,0:5))
lossgainjump_fits<-foreach(i=1:niter)%dopar%{
phytools::fitMk(squamate_tree,hind_digits,
model=D,pi="fitzjohn",rand_start=TRUE,
lik.func="lik",logscale=TRUE)
}
## get log-likelihoods
lnL<-sapply(lossgainjump_fits,logLik)
lnL
## new best model
squamate_lossgain_jump<-lossgainjump_fits[[which.max(lnL)]]
## stop cluster
stopCluster(cl=mc)
## re-run comparison
anova(
squamate_er,
squamate_lossonly_1r,
squamate_lossgain_2r,
squamate_lossonly_5r,
squamate_lossonly_jump,
squamate_lossgain_10r,
squamate_lossgain_jump)
lnL
save.image("C:/Users/liamj/Dropbox/courses/BIOL634-fall2025/hw/4/hw4-solution.RData")
setwd("../Dropbox/courses/BIOL634-fall2025/hw/4")
list.files()
## load packages
library(phytools)
library(geiger)
## read data
squamate_data<-read.csv(
file="https://liamrevell.github.io/biol634/data/brandley_table.csv",
row.names=1)
## read tree
squamate_tree<-read.nexus(
file="https://liamrevell.github.io/biol634/data/squamate.tre")
## address mismatch problem
rownames(squamate_data)<-gsub(" ","_",rownames(squamate_data))
## run name.check
geiger::name.check(squamate_tree,squamate_data)
## subsample my data frame
squamate_data<-squamate_data[squamate_tree$tip.label,]
## re-run name.check
name.check(squamate_tree,squamate_data)
## extract hind digit number
hind_digits<-setNames(round(squamate_data$Toes),
rownames(squamate_data))
head(hind_digits)
## first thing!
?fitMk
## fit using phytools first
squamate_er<-fitMk(squamate_tree,hind_digits,
model="ER",pi="fitzjohn")
squamate_er
## fit same model using geiger::fitDiscrete
squamate_er.geiger<-fitDiscrete(squamate_tree,
hind_digits,model="ER")
hind_digits
as.factor(hind_digits)
as.factor(hind_digits)->hind_digits
## fit using phytools first
squamate_er<-fitMk(squamate_tree,hind_digits,
model="ER",pi="fitzjohn")
## fit same model using geiger::fitDiscrete
squamate_er.geiger<-fitDiscrete(squamate_tree,
hind_digits,model="ER")
squamate_er.geiger
squamate_er
D<-matrix(c(
0,0,0,0,0,0,
1,0,0,0,0,0,
0,1,0,0,0,0,
0,0,1,0,0,0,
0,0,0,1,0,0,
0,0,0,0,1,0),
6,6,byrow=TRUE)
D<-matrix(c(
0,0,0,0,0,0,
1,0,0,0,0,0,
0,1,0,0,0,0,
0,0,1,0,0,0,
0,0,0,1,0,0,
0,0,0,0,1,0),
6,6,byrow=TRUE,
dimnames=list(levels(hind_digits),levels(hind_digits)))
D
squmate_lossonly_1r<-fitMk(squamate_tree,
hind_digits,model=D,pi="fitzjohn")
squamate_lossonly_1r<-fitMk(squamate_tree,
hind_digits,model=D,pi="fitzjohn")
## same model using geiger
squamate_lossonly_1r.geiger<-fitDiscrete(squamate_tree,
hind_digits,model=D)
squamate_lossonly_1r
squamate_lossonly_1r.geiger
plot(squamate_lossonly_1r.geiger,show.zeros=FALSE)
plot(squamate_lossonly_1r)
plot(squamate_lossonly_1r,show.zeros=FALSE)
?fitDiscrete
D<-matrix(c(
0,2,0,0,0,0,
1,0,2,0,0,0,
0,1,0,2,0,0,
0,0,1,0,2,0,
0,0,0,1,0,2,
0,0,0,0,1,0),
6,6,byrow=TRUE,
dimnames=list(levels(hind_digits),levels(hind_digits)))
D
squamate_lossgain_2r<-fitMk(squamate_tree,hind_digits,
model=D,pi="fitzjohn")
squamate_lossgain_2r
squamate_lossgain_2r.geiger<-fitDiscrete(squamate_tree,
hind_digits,model=D)
squamate_lossgain_2r.geiger
list.files()
load("hw4-solution.RData")
anova(
squamate_er,
squamate_lossonly_1r,
squamate_lossgain_2r,
squamate_lossonly_jump,
squamate_lossgain_10r,
squamate_lossgain_jump)
anova(
squamate_er,
squamate_lossonly_1r,
squamate_lossgain_2r,
squamate_lossonly_5r,
squamate_lossonly_jump,
squamate_lossgain_10r,
squamate_lossgain_jump)
er_fits<-list()
er_fits<-list()
niter<-10
for(i in 1:niter){
cat(paste("running optimization iteration",i,"\n"))
er_fits[[i]]<-fitMk(squamate_tree,hind_digits,
model="ER",pi="fitzjohn",rand_start=TRUE)
}
er_fits
## loss/gain + jump
D<-matrix(c(
0,0,0,0,0,0,
1,0,0,0,0,0,
4,2,0,0,0,0,
4,0,2,0,0,0,
4,0,0,2,0,0,
4,0,0,0,3,0),
6,6,byrow=TRUE,
dimnames=list(levels(hind_digits),levels(hind_digits)))
D
library(foreach)
library(doParallel)
niter<-10
detectCores()
ncores<-min(niter,detectCores()-2)
ncores
mc<-makeCluster(ncores,type="PSOCK")
registerDoParallel(cl=mc)
## loss/gain + jump
D<-matrix(c(
0,0,0,0,0,0,
1,0,0,0,0,0,
4,2,0,0,0,0,
4,0,2,0,0,0,
4,0,0,2,0,0,
4,0,0,0,3,0),
6,6,byrow=TRUE,
dimnames=list(levels(hind_digits),levels(hind_digits)))
D
sample(c(TRUE,FALSE),1)
sample(c(TRUE,FALSE),1)
dannys_model_fits<-foreach(i=1:niter)%dopar%{
phytools::fitMk(squamate_tree,hind_digits,
model=D,pi="fitzjohn",rand_start=TRUE,
lik.func="lik",logscale=sample(c(TRUE,FALSE),1))
}
dannys_model_fits
stopCluster(cl=mc)
lnL<-sapply(dannys_model_fits,logLik)
lnL
which.max(lnL)
danny_model<-dannys_model_fits[[which.max(lnL)]]
danny_model
plot(danny_model,width=TRUE,color=TRUE)
## graph fitted model
plot(squamate_lossonly_1r,show.zeros=FALSE)
plot(squamate_lossonly_1r.geiger,show.zeros=FALSE)
getwd()
setwd("../../biol634/")
